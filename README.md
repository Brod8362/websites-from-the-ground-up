# From the Ground Up

This document has the following goals:

- Explain how a "website" is made
- Explain how HTTP works
- Explain what a "static" vs "dynamic" site is, and describe their advantages/limitations
- Show how combining a few simple tools allows you to create complex functionality
- Explain modular principles, to maximize code reuse
- Show how unit testing can be used to ensure site functionality & detect breaking code changes

Fully functional examples for the three examples (static, static+htmx, dynamic+htmx) are provided for reference and visual aid.

# Terminology

First, I want to cover some terminology that will be used throughout this document.

- A web server is an application that serves content via the HTTP protocol.
- A *static* web server is a web server which has no functionality beyond serving content that already exists.
- A *dynamic* web server is a web server which is able to take action beyond simply serving content, for enhanced functionality.
- HTTP is a request/response protocol that is typically used to serve files to web browsers.
- HTML is a markup language, used to represent the content and organization of a web page. It is rendered into graphical content by web browsers.
- htmx is a JavaScript library which adds custom HTML properties to allow the site to be manipulated dynamically with minimal effort.
- Rust is a programming language, focused on memory and thread safety.
- A request handler is a vague entity (typically a function on a web server) which accepts an HTTP request and produces an HTTP response.
- Rocket is a Rust library/framework, which allows for accepting HTTP requests and sending responses. You can write custom code in the request handler.
- A template is a file (in this context, HTML content) with some fields intentionally left as placeholders, with intent to fill the placeholders later.


# How does a website work?

~~The internet is a series of tubes~~

Ok, jokes aside, at it's core, a "website" is simply just a web server that you can make requests to. 
When you (or more likely your browser) make an HTTP request, the request is sent over a network.

When the server receives your request, it will product a response, which is then sent back to the client (you)

How exactly this response is interpreted is up to the client, but generally, your web browser will display the content the server sent back to you.

## HTTP

HTTP *requests* are made up of a few parts:

- The HTTP version (e.g `HTTP/1.1`)
- The request verb (`GET`, `POST`, `PUT`, etc)
- The request path (e.g `/index.html`)
- The request headers, which are additional key/value metadata pairs sent in the request.
- An optional body, which is only allowed with some verbs (e.g `POST`, `PUT`, `PATCH`). This body can be anything.

Here's an example of an HTTP request, trimmed for brevity.

```http
GET / HTTP/1
Host: localhost:8000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:123.0) Gecko/20100101 Firefox/123.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
DNT: 1
Connection: keep-alive
```

Once the server receives the request, it processes this data, and produces a response, with the following fields:

- The status code, a three-digit number generally summarizing how the request went. 2xx means OK, 4xx means client error, 5xx means server error. Read more about status codes on [Mozilla's MDN Docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
- The HTTP version, as before
- The response headers
- The response body (if any)

Here's an example of an HTTP response (the response to the above request), trimmed for brevity.

```http
HTTP/1.0 200 OK
Server: SimpleHTTP/0.6 Python/3.11.8
Date: Sat, 23 Mar 2024 20:02:14 GMT
Content-type: text/html
Content-Length: 261
Last-Modified: Sat, 23 Mar 2024 18:54:12 GMT

<!DOCTYPE html>
<head>
    <title>Main Page</title>
</head>
<body>
<!-- trimmed here for brevity -->
</body>
```

There's a lot of information about HTTP on [Mozilla's docs](https://developer.mozilla.org/en-US/docs/Web/HTTP). 
The rest of this content assumes a basic familiarity of HTTP, and what the different verbs mean.

# Static web server

A static web server is once which simply serves static content - it takes your HTTP requests and gives you back files that already exist, in their entirety.
They do not have functionality to dynamically process data - as such, they are deterministic. The same request should always produce the same response.

Static web servers are great for sites like blogs, where the content changes infrequently and there is no reason to add complexity.
Often, the content is not written by hand, but generated by a "Static static generator". 
[Hugo](https://gohugo.io/) is an example of a popular static site generator, it takes markdown files and generates HTML out of it, that can be then served by a web server.

Please refer to the files in the `/static` folder, and run the web server with `python -m http.server`. [Click here to open the page in your browser](http://localhost:8000)

Observe how you can click on the various colors to view them - but every time you click, you get brought to an entirely different page. If you want to view another color, you have to click on the back button to go back to the home page.

Additionally, each of pages needed to be created separately with different content. If I wanted to scale up to have more than just four colors, I would have to make a new page for every single color I want to support.

## Advantages

- Because static web servers are so simple, they are typically very performant and simple to set up. It's barely more complicated than parsing the file you want and formatting an HTTP request to then send it back to you. 

- They are typically easy to secure, just make sure no sensitive content is in the folder that the web server is serving, and you're *basically* done. (This is a bit oversimplified)

- The site is the same if JavaScript is disabled, or if it is not supported at all.

## Drawbacks

- Static web servers are just what they say on the tin - *static*. It is not possible to serve dynamically changing content, unless you offload that work to the client (via JS).
Offloading work to the client is a valid strategy, but it adds complexity and can hurt the performance/responsiveness of your site. (For all you know, your client is a very slow iPhone 4)

- If you want to update the page content, you must refresh the entire page. This is simply because of the architecture of browsers, and how HTML/HTTP were designed.

- That means every time your user navigates to a different section of your site, the entire page must reload.

- Alternatively, you can write custom JavaScript to update the content on the page, but that comes with performance and other concerns, as well as consuming more development time.

# Static + htmx

Wouldn't it be nice if we could change small parts of the page without having to reload the entire site again?

Of course, that is possible - you can write JavaScript to do that for you.

But writing JavaScript manually is time consuming, and you might need to write it multiple times if you want to have slightly different behavior.

Wouldn't it be nice if I could just take this one HTML element and swap it out with another one at the click of a button?

...

Turns out, you can! Introducing [htmx](https://htmx.org/)

htmx is a *client*-side JavaScript library which adds some custom HTML attributes that allow you to easily specify behavior for swapping elements on the page, in response to certain events (such as a button being clicked).

The most relevant of such attributes are `hx-get`, `hx-post`, and `hx-target`. 

`hx-post` is not very useful in the context of a static webserver, as it has no facilities to handle `POST` requests. However, `GET` requests are useful, and this allows us to add some more functionality to our color-viewing site.

By making a `div` container and slightly adjusting the `blue.html`, `red.html`, etc, we can use the `hx-get` and `hx-target` properties to swap the contents of those documents right into this page!

Please run the web server in `static-htmx` as specified in the instructions, and observe how these relatively small changes already allow us to make a more interactive site with very little work.

(If you're having issues with the squares not displaying properly, your browser most likely cached the pages from the previous example. Clear your cache or force-refresh and try again. These examples are tested and known to work properly.)

## Advantages

- With a small amount of work, we can greatly improve the usability of our site.

- All of the heavy lifting is being performed by the server - keeping things fast & snappy.

## Drawbacks

- We do have to offload a very small amount of work to the client to perform the elemenet swapping - however, this work is very minimal and should not be a performance burden in any context. (Especially compared to the heavy JS frameworks that are so popular today)

- JavaScript is required for the site to funcion properly.

- We are still creating each page manually, and there is a lot of repetition in the various color block pages.

- When swapping elements in like this, there can be oddities revolving CSS styling and if it applies to the elements. However, as long as you use classes that were loaded with the main page, there should be no issues.

- It can be challenging to swap multiple disparate elements (but not impossible, see [out of band swaps](https://htmx.org/docs/#oob_swaps))

# Dynamic + htmx

A dynamic web server is one that instead of simply serving static files from disk, can take the parameters of a request and generate content *dynamically* - that is, changing on the input, and not pre-determined.

In this case, our choice of web server is [Rocket](https://rocket.rs/) - a library/HTTP server for the Rust programming language.

By upgrading to a "dynamic" web server, we're going to add the following functionality:

- Use HTML templates to minimize boilerplate code (maximize code reuse)
- Add functionality to our site in the form of a "favorite color" option, which is stored by the server.

Please run the web server with the provided instructions (it's different this time), and observe how the site behaves.

All of the color blocks are rendered from the same template, `color_block.html.tera`. The server can, at runtime, substitute any color into this template.

This means now instead of writing red/blue/green/yellow, separately, they all share this one file. We can also now support as many colors as we want with very little work (in fact, they're all already supported! We'd just need to add buttons for them)

Additionally, in the color block template, there's a button to "set as favorite". When this button is clicked, it makes a POST request to the server, asking it to store the favorite color. When the user clicks on the "favorite color" button, it will display this color back to them.

Now with htmx and a dynamic backend, we can accomplish almost anything. The scope of this document is very limited, and it is only a *very* simple example of what you can do. 

This kind of set up is not suitable for every kind of website - but for the ones where it is, it greatly increases development time and decreases complexity. 

(As an example, it should be very possible to create a chat service like discord using only htmx!)

## Advantages

- Dynamic backend means more possibilities

- Can create complex sites and interfaces with no work required on the client (= fast!)

## Disadvantages

- Dynamic webservers are inherently more prone to bugs and security flaws, as custom code always is.

- Server might expend more resources to render the site (but it really shouldn't be that much)

- Not 100% as much functionality as a framework like React might have (counterpoint: that functionality is not always necessary in many cases)